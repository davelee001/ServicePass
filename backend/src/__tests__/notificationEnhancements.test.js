const NotificationManager = require('../../../src/utils/notificationManager');
const NotificationPreferences = require('../../../src/models/NotificationPreferences');
const NotificationHistory = require('../../../src/models/NotificationHistory');
const User = require('../../../src/models/User');
const notificationService = require('../../../src/utils/notificationService');
const { connectDB, clearDB, closeDB } = require('../setup');\n\n// Mock notification service\njest.mock('../../../src/utils/notificationService');\n\ndescribe('Enhanced Notification Manager', () => {\n    let notificationManager;\n    \n    beforeAll(async () => {\n        await connectDB();\n        notificationManager = new NotificationManager();\n    });\n    \n    afterAll(async () => {\n        await closeDB();\n    });\n    \n    beforeEach(async () => {\n        await clearDB();\n        jest.clearAllMocks();\n        \n        // Mock notification service methods\n        notificationService.sendEmail.mockResolvedValue({ messageId: 'email-123' });\n        notificationService.sendSMS.mockResolvedValue({ sid: 'sms-123' });\n        notificationService.sendBulkPushNotifications.mockResolvedValue({ successCount: 1 });\n    });\n    \n    describe('Retry Mechanism', () => {\n        test('should add failed notifications to retry queue', async () => {\n            const notificationData = {\n                userId: 'test-user',\n                type: 'voucher_received',\n                data: { voucherId: 'voucher-123' },\n                options: { priority: 'high' }\n            };\n            \n            const result = await notificationManager.addToRetryQueue(notificationData);\n            \n            expect(result).toBe(true);\n            expect(notificationManager.retryQueue.size).toBe(1);\n        });\n        \n        test('should not retry beyond max attempts', async () => {\n            const notificationData = {\n                userId: 'test-user',\n                type: 'voucher_received',\n                data: { voucherId: 'voucher-123' },\n                options: { priority: 'high' }\n            };\n            \n            const result = await notificationManager.addToRetryQueue(notificationData, 4); // Exceeds max retries\n            \n            expect(result).toBe(false);\n            expect(notificationManager.retryQueue.size).toBe(0);\n        });\n        \n        test('should use exponential backoff for retry delays', async () => {\n            const notificationData = {\n                userId: 'test-user',\n                type: 'voucher_received',\n                data: { voucherId: 'voucher-123' },\n                options: { priority: 'high' }\n            };\n            \n            await notificationManager.addToRetryQueue(notificationData, 1);\n            await notificationManager.addToRetryQueue(notificationData, 2);\n            \n            const retryItems = Array.from(notificationManager.retryQueue.values());\n            \n            expect(retryItems[0].retryTime).toBeLessThan(retryItems[1].retryTime);\n        });\n    });\n    \n    describe('Bulk Notifications', () => {\n        test('should queue bulk notifications', async () => {\n            const notifications = [\n                {\n                    userId: 'user-1',\n                    type: 'voucher_received',\n                    data: { voucherId: 'voucher-1' }\n                },\n                {\n                    userId: 'user-2',\n                    type: 'voucher_received',\n                    data: { voucherId: 'voucher-2' }\n                }\n            ];\n            \n            const result = await notificationManager.sendBulkNotifications(notifications);\n            \n            expect(result.total).toBe(2);\n            expect(result.status).toBe('queued');\n            expect(result.batchId).toBeDefined();\n            expect(notificationManager.batchQueue.size).toBe(1);\n        });\n        \n        test('should respect custom batch size', async () => {\n            const notifications = new Array(10).fill(null).map((_, i) => ({\n                userId: `user-${i}`,\n                type: 'voucher_received',\n                data: { voucherId: `voucher-${i}` }\n            }));\n            \n            const result = await notificationManager.sendBulkNotifications(notifications, { batchSize: 3 });\n            \n            expect(result.total).toBe(10);\n            \n            const batchData = notificationManager.batchQueue.get(result.batchId);\n            expect(batchData.batchSize).toBe(3);\n        });\n    });\n    \n    describe('Scheduled Notifications', () => {\n        test('should schedule notification for future delivery', async () => {\n            const userId = 'test-user';\n            const type = 'system_maintenance';\n            const data = { maintenanceType: 'Database upgrade' };\n            const scheduleTime = new Date(Date.now() + 60000); // 1 minute from now\n            \n            const result = await notificationManager.scheduleNotification(\n                userId,\n                type,\n                data,\n                scheduleTime\n            );\n            \n            expect(result.scheduleId).toBeDefined();\n            expect(result.status).toBe('scheduled');\n            expect(notificationManager.scheduledNotifications.size).toBe(1);\n        });\n        \n        test('should cancel scheduled notification', async () => {\n            const scheduleResult = await notificationManager.scheduleNotification(\n                'test-user',\n                'system_maintenance',\n                { maintenanceType: 'Test' },\n                new Date(Date.now() + 60000)\n            );\n            \n            const cancelResult = notificationManager.cancelScheduledNotification(scheduleResult.scheduleId);\n            \n            expect(cancelResult.success).toBe(true);\n            expect(notificationManager.scheduledNotifications.size).toBe(0);\n        });\n    });\n    \n    describe('Rate Limiting', () => {\n        test('should allow notifications within rate limits', async () => {\n            const userId = 'test-user';\n            const type = 'voucher_received';\n            \n            const allowed = await notificationManager.checkRateLimit(userId, type);\n            \n            expect(allowed).toBe(true);\n        });\n        \n        test('should block notifications exceeding rate limits', async () => {\n            const userId = 'test-user';\n            const type = 'voucher_received';\n            \n            // Simulate multiple rapid requests\n            for (let i = 0; i < 11; i++) {\n                await notificationManager.checkRateLimit(userId, type);\n            }\n            \n            const blocked = await notificationManager.checkRateLimit(userId, type);\n            \n            expect(blocked).toBe(false);\n        });\n        \n        test('should provide rate limit status', async () => {\n            const userId = 'test-user';\n            \n            // Make some requests\n            await notificationManager.checkRateLimit(userId, 'voucher_received');\n            await notificationManager.checkRateLimit(userId, 'voucher_received');\n            \n            const status = await notificationManager.getRateLimitStatus(userId);\n            \n            expect(status.voucher_received).toBeDefined();\n            expect(status.voucher_received.requests).toBe(2);\n            expect(status.voucher_received.remainingRequests).toBe(8);\n        });\n    });\n    \n    describe('Analytics', () => {\n        test('should track notification metrics', async () => {\n            // Simulate some successful notifications\n            notificationManager.analytics.totalSent = 10;\n            notificationManager.analytics.totalFailed = 2;\n            notificationManager.analytics.channelStats.email = 5;\n            notificationManager.analytics.channelStats.sms = 7;\n            \n            const analytics = notificationManager.getAnalytics();\n            \n            expect(analytics.totalNotifications).toBe(12);\n            expect(analytics.successRate).toBe(83.33333333333334); // 10/12 * 100\n            expect(analytics.channelStats.email).toBe(5);\n        });\n        \n        test('should provide user-specific analytics', async () => {\n            const userId = 'test-user';\n            \n            // Create test user\n            await User.create({ userId, email: 'test@example.com', name: 'Test User' });\n            \n            // Create notification history\n            await NotificationHistory.create({\n                userId,\n                type: 'voucher_received',\n                channel: 'email',\n                status: 'sent',\n                recipient: 'test@example.com'\n            });\n            \n            await NotificationHistory.create({\n                userId,\n                type: 'voucher_expiring',\n                channel: 'sms',\n                status: 'failed',\n                recipient: '+1234567890'\n            });\n            \n            const analytics = await notificationManager.getUserAnalytics(userId);\n            \n            expect(analytics.totalNotifications).toBe(2);\n            expect(analytics.statusStats.sent).toBe(1);\n            expect(analytics.statusStats.failed).toBe(1);\n            expect(analytics.channelStats.email).toBe(1);\n            expect(analytics.channelStats.sms).toBe(1);\n            expect(analytics.successRate).toBe(50);\n        });\n    });\n    \n    describe('Enhanced Templates', () => {\n        test('should support custom variables in templates', async () => {\n            const template = notificationManager.getTemplate(\n                'voucher_received',\n                { voucherType: 'Education', amount: 100 },\n                'high',\n                { customMessage: 'Special promotion!' }\n            );\n            \n            expect(template).toBeDefined();\n            expect(template.email.subject).toContain('ServicePass');\n        });\n        \n        test('should include system variables', async () => {\n            const template = notificationManager.getTemplate(\n                'voucher_received',\n                { voucherType: 'Education', amount: 100 }\n            );\n            \n            // Templates should have access to system variables like frontendUrl\n            expect(template).toBeDefined();\n        });\n        \n        test('should support different priority levels', async () => {\n            const highPriorityTemplate = notificationManager.getTemplate(\n                'voucher_received',\n                { voucherType: 'Education', amount: 100 },\n                'high'\n            );\n            \n            const lowPriorityTemplate = notificationManager.getTemplate(\n                'voucher_received',\n                { voucherType: 'Education', amount: 100 },\n                'low'\n            );\n            \n            expect(highPriorityTemplate).toBeDefined();\n            expect(lowPriorityTemplate).toBeDefined();\n        });\n        \n        test('should support new template types', async () => {\n            const maintenanceTemplate = notificationManager.getTemplate(\n                'system_maintenance',\n                {\n                    maintenanceType: 'Database upgrade',\n                    startTime: '2024-02-15 02:00 UTC',\n                    endTime: '2024-02-15 04:00 UTC',\n                    affectedServices: 'User dashboard',\n                    description: 'Upgrading database for better performance'\n                }\n            );\n            \n            expect(maintenanceTemplate).toBeDefined();\n            expect(maintenanceTemplate.email.subject).toContain('Maintenance');\n            expect(maintenanceTemplate.sms).toContain('maintenance');\n            expect(maintenanceTemplate.push.title).toContain('Maintenance');\n        });\n        \n        test('should support security alert template', async () => {\n            const securityTemplate = notificationManager.getTemplate(\n                'security_alert',\n                {\n                    alertType: 'Suspicious login',\n                    timestamp: '2024-02-13 15:30:00',\n                    ipAddress: '192.168.1.100',\n                    action: 'Login attempt',\n                    location: 'New York, USA'\n                }\n            );\n            \n            expect(securityTemplate).toBeDefined();\n            expect(securityTemplate.email.subject).toContain('Security Alert');\n            expect(securityTemplate.sms).toContain('Security Alert');\n            expect(securityTemplate.push.title).toContain('Security Alert');\n        });\n        \n        test('should support bulk operation completion template', async () => {\n            const bulkTemplate = notificationManager.getTemplate(\n                'bulk_operation_complete',\n                {\n                    operationType: 'Voucher Minting',\n                    batchId: 'batch_123',\n                    totalRecords: 100,\n                    successCount: 95,\n                    failureCount: 5,\n                    duration: '2m 30s'\n                }\n            );\n            \n            expect(bulkTemplate).toBeDefined();\n            expect(bulkTemplate.email.subject).toContain('Bulk');\n            expect(bulkTemplate.email.subject).toContain('Complete');\n            expect(bulkTemplate.sms).toContain('complete');\n            expect(bulkTemplate.push.title).toContain('Operation Complete');\n        });\n    });\n});